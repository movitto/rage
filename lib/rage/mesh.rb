# Mesh Resource
#
# Currently manages X3D meshes
#
# Copyright (C) 2010 Mohammed Morsi <movitto@yahoo.com>
# Licensed under the GPLv3+ http://www.gnu.org/licenses/gpl.txt

# use rxsd to load x3d xsd schema, declare xsd classes, instantiate scenes
require 'rxsd'

module RAGE

# 3D mesh to be displayed on the screen. 
# Contains geometry and visual properties.
# Currently implements certain parts of the X3D graphics schema.
# http://en.wikipedia.org/wiki/X3D
class Mesh
  # Optional transformation params, set these to 
  # transformations to be factored in if needed
  attr_accessor :op_translation, :op_scale, :op_rotation

  # X3D schema for shared access
  class_attr :x3d_schema

  # X3D schema classes for shared access
  class_attr :x3d_schema_classes


  # Create new mesh from raw X3D mesh
  def initialize(data)
     # set default attributes
     @op_translation =  [0,0,0]
     @op_scale       =  [1,1,1]

     # load the x3d xsd schema and classes if not already done so
     unless defined? @@x3d_schema
       @@x3d_schema = RXSD::Parser.parse_xsd :uri => 'http://www.web3d.org/specifications/x3d-3.0.xsd' # TODO allow location which this is pulled from to be configured
       @@x3d_schema_classes = @@x3d_schema.to :ruby_classes
     end

     # load the scene from the x3d schema instance
     objs = RXSD::Parser.parse_xml(:raw => data).to(:ruby_objects, :schema => @@x3d_schema)
     @scene = objs[0].scene

     # FIXME get all transformations (and groups of) under scene
     @tf = @scene.collision.transform
     @translation = @tf.translation.to_xa :type => XSDFloat
     @scale       = @tf.scale.to_xa :type => XSDFloat
     #diffuse     = tf.shape.appearance.material.diffuse_color.split.collect { |c| c.to_f }
     #specular    = tf.shape.appearance.material.specular_color.split.collect { |c| c.to_f }
     #emissive    = tf.shape.appearance.material.emissive_color.split.collect { |c| c.to_f }
     @coord_index  = @tf.shape.indexed_face_set.coord_index.
                                     to_xa(:type => String, :delim => ",").
                                     collect { |coords| a = coords.to_xa(:type => XSDInteger); a[0...a.size-1]}.flatten # cut off the last -1
     @coord_point  = @tf.shape.indexed_face_set.coordinate.point.
                                     to_xa(:type => String, :delim => ",").
                                     collect { |coords| coords.to_xa :type => XSDFloat }.flatten
  end

  # Create location w/ specified args, associated mesh w/ it and add it to the LocationsManager
  def show_at(args = {})
    # XXX not a huge fan of storing location interally,
    # but this is best way to do this for now
    if ! defined? @location
      args[:mesh] = self
      @location = Location.new(args)
      LocationsManager.instance.add @location
    else
      @location.update args
    end
    return @location
  end

  # Return current location coordinates associated w/ the mesh
  def coordinates
    [@location.x, @location.y, @location.z]
  end


  # Return center point of mesh from mesh translation provided in mesh 
  # and op_translation
  def center
     return @op_translation[0] + @translation[0],
            @op_translation[1] + @translation[1],
            @op_translation[2] + @translation[2]
  end

  # Return factor which mesh should scale to
  def scale
     return @scale[0] * @op_scale[0],
            @scale[1] * @op_scale[1],
            @scale[2] * @op_scale[2]
  end

  # Return mesh boundaries. This is generated by determining the maxima/minima
  # coordinate points. Return value is an array of six values as follows
  #   max_x, max_y, max_z, min_x, min_y, min_z
  def boundaries
     centerx, centery, centerz = *center
     max_x = max_y = max_z = min_x = min_y = min_z = 0
     @coord_point.each_index {  |cpi|
        if cpi % 3 == 0
          adjx = centerx + @coord_point[cpi]
          if  adjx > max_x
             max_x = adjx
          elsif adjx < min_x
             min_x = adjx
          end
        elsif cpi % 3 == 1 
          adjy = centery + @coord_point[cpi]
          if adjy > max_y
             max_y = adjy
          elsif adjy < min_y
             min_y = adjy
          end
        else
          adjz = centerz + @coord_point[cpi]
          if adjz > max_z
             max_z = adjz
          elsif adjz < min_z
             min_z = adjz
          end
        end
     }
     return max_x, max_y, max_z, min_x, min_y, min_z
  end


  # Invoked during draw cycle to draw mesh
  def draw
     # FIXME mesh material
     #Gl.glMaterial(Gl::GL_FRONT, Gl::GL_DIFFUSE,  diffuse)
     #Gl.glMaterial(Gl::GL_FRONT, Gl::GL_SPECULAR, specular)
     #Gl.glMaterial(Gl::GL_FRONT, Gl::GL_EMISSIVE, emissive)

     # translate coordinate system to center position of mesh
     Gl.glTranslatef(*center)

     # scale as specified 
     Gl.glScalef(*scale)

     # FIXME rotate according to mesh and optional params

     # draw mesh
     Gl.glEnableClientState(Gl::GL_VERTEX_ARRAY);
     Gl.glVertexPointer(3, Gl::GL_FLOAT, 0, @coord_point);
     Gl.glDrawElements(Gl::GL_QUADS, @coord_index.size, Gl::GL_UNSIGNED_INT, @coord_index);
     Gl.glDisableClientState(Gl::GL_VERTEX_ARRAY);
  end
end

end
